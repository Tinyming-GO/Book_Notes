# 第1章 PHP解惑
## 1.1 省略结束标签的便利性
## 1.2 empty、isset、is_null的区别

- isset() 用来检测一个变量是否已声明且值不为NULL
- empty() 用来检测一个变量是否为空：空字符串，false，空数组[array()],NULL，0，''，以及被unset删除后的变量。
- is_null() 只针对已声明变量

## 1.3 布尔值的正确打开方式（TRUE/FALSE 建议大写，因为是常量）

## 1.4 变量作用域实践（函数体内访问外部变量 `global $globalName`）

## 1.5 多维数组排序

- 一维数组排序常用sort()、ksort()等
- 二维、多维数组排序，需要自定义排序函数:

`uasort()`函数接受两个参数，并且返回一个值表示那个参数应该排在前面。负数或者FALSE意味着第一个参数应该排在第二个参数之前。正数或者TRUE表示第二个参数应该排前面，如果值为0，则表示两个参数相等。

```php
<?php

//定义多维数组
$a = array(
    array('sky', 'blue'),
    array('apple', 'red'),
    array('tree', 'green'),
);
//自定义数组比较函数，按数组的第二个元素进行比较
function my_compare($a, $b) {
    if($a[1] < $b[1]) {
        return -1;
    } else if($a[1] == $b[1]) {
        return 0;
    } else {
        return 1;
    }
}

//排序
usort($a,'my_compare'); //PHP会把内层数组不断地发送给自定义函数
//输出结果
print_r($a);
```

## 1.6 超级全局数组

超级全局数组（super global array）是由PHP内置的，无须开发者重新定义。PHP执行脚本时会自动收集信息并赋值给这些数组。共有十多个分类。

| 名称 | 功能 |
|--------|--------|
| $_GET[]       |   取得用GET方法提交的表单内容，数组键和值分别对应元素名和值     |
| $_POST[]       |   取得用POST方法提交的表单内容，数组键和值分别对应元素名和值     |
| $_COOKIE[]       |   取得或设置当前站点的Cookie     |
| $_SESSION[]       |   取得当前用户访问的会话，以数组形式体现，如sessionid及自定义session数据     |
| $_ENV[]       |   当前PHP服务器的环境变量     |
| $_SERVER[]       |   当前PHP运行环境的服务器变量     |
| $_FILES[]       |   用户上传文件时提交到当前脚本参数     |
| $_REQUEST[]       |   包含当前脚本提交的所有请求，它包含了$_GET[]、$_POST[]、$_COOKIE[]、$_SESSION[]这些超级全局数组的全部内容     |
| $GLOBALS[]       |   该超级变量数组包含正在执行脚本时所有超级全局数组的内容     |

## 1.7 global 关键字与 global 数组的区别

`$GLOBALS['var']` 是外部的全局变量本身，`global $var` 是外部$var的同名引用或者指针，如：

- $GLOBALS['var']

```php
<?php

$var1 = 1;

function test() {
    unset($GLOBALS['var1']);
}

test();
echo $var1; //因为$var1变量被删除，所以没有内容显示出来
```

- global $var

```php
<?php

$var1 = 1;

function test() {
    global $var1;
    unset($var1);
}

test();
echo $var1; //输出 1
```

综上：
- $GLOBALS['var'] 是外部的全局变量本身
- global $var 是外部$var的同名引用或者指针

## 1.8 活用静态变量（静态变量 在函数执行完时不会销毁，脚本执行完时才销毁）

函数内部创建的局部变量，会在函数执行完毕时立即删除。有时为了保存上次局部变量执行的结果，以便下次执行时使用，这时就可以用静态变量来实现。

```php
<?php

function myFunction() {
    static $myVar = 0;
    echo ++$myVar;
}

myFunction(); // 1
myFunction(); // 2
myFunction(); // 3
```

## 1.9 require、require_once、include、include_once与autoload

- 没有once意味着允许多次执行
- include()、include_once()，包含失败会显示警告错误，然后还会继续执行。如果是require()、require_once(),包含文件失败后会抛出致命错误并中止脚本
- 生产环境中，注意千万不要把程序错误信息抛给用户，可在代码中使用error_reporting(0)禁止所有的错误显示，内部加入完善的错误及日志处理，显示给用户正常内容即可。
- require_once()要慢于require，使用autoload速度最快。

Apache为我们提供了ab工具，用来测试脚本性能，及并发。

`ab -c 10 -n 100000 localhost/index.php` 模拟了10万个请求，同一时间有10个并发请求

## 1.10 = 与 =\=、===的区别
## 1.11 HereDoc 与 NowDoc

```php
<?php

$a = 'hallo';

$hereDoc = <<<HEARDOC
 {$a} world;
HEARDOC;

$nowDoc = <<<'NOWDOC'
 {$a} world;
NOWDOC;

echo $hereDoc; // hallo world;
echo '\n';
echo $nowDoc; // {$a} world;
```

## 1.12 函数传值与引用

函数传值的两种方式：

- 传值

括号内加入相应变量名：

`function getUserInfo($f,$s,$t){}`

使用`func_get_arg()`函数来直接处理：

```php
function getUserInfo() {
    $f = func_get_arg(0);
    $s = func_get_arg(1);
    $t = func_get_arg(2);
}
```

如果还觉得繁琐，可以将`func_get_arg()`函数返回的内容交给数组，再进行处理：

```php
function getUserInfo() {
    $args = func_get_args();
    $f = $args(0);
    $s = $args(1);
    $t = $args(2);
}
```

※ 值传递，不是引用！举例：$a = $b; 删除$a，不影响$b;

- 引用

需要在对应的参数前加上“&”符号

```php
function build_now(&$text) { //函数的形参需要+‘&’
    return $text;
}

$t = 'hallo';
$row = &build_now($t); //引用方式调用函数
echo $t;
```

※ `&build_now($t)` 注意，调用函数时也需要用&符号来声明是引用操作。

## 1.13 避免使用过多参数

尽量避免在函数或方法中使用过多的参数。也不提倡使用全局变量！

- 使用数组

```php
$bar = func(array('dude', 'where is my', 'car'));

function func($args) { //使用数组作为参数
    $f = $args[0];
    $s = $args[1];
    $t = $args[2];
}
```

- 使用对象

```php
//User类 用来定义参数
class User {
    public $user_name;
    public $type;
    public $email;
    public $address;
    public $city;
    public $country;
    public $gender;
    //...
}

class UserCsvTemplate {
    //传入User类
    public function render(User $user) {
        echo $user->user_name, ';', $user->country; //获取对应参数
    }
}

//先实例化User,然后赋值
$user = new User();
$user->user_name = 'xiaoming';
$user->country = 'guangzhou';

$template = new UserCsvTemplate();
$template->render($user); //调用时传入user对象
```

※ 这种方式可以准确获取参数，又能避免方法参数过多！推荐！

## 1.14 匿名函数

- 匿名函数赋值给变量

```php
$greet = function($name) {
    printf('hello %s', $name);
};

$greet('xiaoming');
```

- array_map()函数

```php
function format_name($name) {
    echo "{$name}/";
}

$names = array('xiaoming', 'dazhuang');
array_map('format_name', $names); //输出 xiaoming/dazhuang/

// array_map() 第一个参数是函数名，第二个参数是个数组。数组内的每个元素都将使用之前的函数遍历一遍。
```

- 无名字的匿名函数

```php
array_map(function($val) {
    //etc
}, $names);
```

好处：相关代码、函数定义与隐式调用精密结合。
坏处：有可能出现解释错误。出现错误时，可以把函数中代码放进一个正常的函数体中执行，调试到没有问题为止。

- 匿名函数可以使用闭包(比较少用)

```php
$x = 3;
$func = function() use (&$x) {
    $x *= 2;
};
$func();
echo $x; // 打印结果为 6
```

## 1.15 return 与 exit

想要在方法里中断函数的运行并返回调用处时要使用无返回值的return， 而不要使用exit 或 exit()函数。

## 1.16 is_callable() 与 method_exists() 函数

检查一个对象里的方法是否存在？常用 `method_exists($object, 'SomeMethod')`。但该方法仅能判断是否存在方法，却无法判断方法是否可访问（protected/private）,会报fetal error错误。

举例说明 is_callable() 与 method_exists() 的区别：

```php
class Foo {
    public function PublicMethod() {}
    private function PrivateMethod() {}
    public static function PublicStaticMethod() {}
    private static function PrivateStaticMethod() {}
}

$foo = new Foo();

$callbacks = array(
    array($foo, 'PublicMethod'),
    array($foo, 'PrivateMethod'),
    array($foo, 'PublicStaticMethod'),
    array($foo, 'PrivateStaticMethod'),
    array('Foo', 'PublicMethod'),
    array('Foo', 'PrivateMethod'),
    array('Foo', 'PublicStaticMethod'),
    array('Foo', 'PrivateStaticMethod'),
);

foreach($callbacks as $callback) {
    var_dump($callback);
    var_dump(method_exists($callback[0], $callback[1]));
    var_dump(is_callable($callback));
    echo str_repeat('-', 40);
    echo "\n";
}
```

输出

```bash
array(2) {
  [0]=>
  object(Foo)#1 (0) {
  }
  [1]=>
  string(12) "PublicMethod"
}
bool(true)
bool(true)
----------------------------------------
array(2) {
  [0]=>
  object(Foo)#1 (0) {
  }
  [1]=>
  string(13) "PrivateMethod"
}
bool(true)
bool(false)
----------------------------------------
array(2) {
  [0]=>
  object(Foo)#1 (0) {
  }
  [1]=>
  string(18) "PublicStaticMethod"
}
bool(true)
bool(true)
----------------------------------------
array(2) {
  [0]=>
  object(Foo)#1 (0) {
  }
  [1]=>
  string(19) "PrivateStaticMethod"
}
bool(true)
bool(false)
----------------------------------------
array(2) {
  [0]=>
  string(3) "Foo"
  [1]=>
  string(12) "PublicMethod"
}
bool(true)
bool(true)
----------------------------------------
array(2) {
  [0]=>
  string(3) "Foo"
  [1]=>
  string(13) "PrivateMethod"
}
bool(true)
bool(false)
----------------------------------------
array(2) {
  [0]=>
  string(3) "Foo"
  [1]=>
  string(18) "PublicStaticMethod"
}
bool(true)
bool(true)
----------------------------------------
array(2) {
  [0]=>
  string(3) "Foo"
  [1]=>
  string(19) "PrivateStaticMethod"
}
bool(true)
bool(false)
----------------------------------------
```

※ 结论：无论对象或者类本身，无论是否静态方法。method_exists()只能判断是否存在方法，存在返回True，不存在返回False。is_callable()可以判断方法是否存在，是否可访问，存在且可访问返回True，不存在或者不可访问返回False。

如果一个对象存在模式方法_\_call()，在进行方法判断时 method_exists() 会返回 FALSE ,而 is_callback() 会返回 TRUE :

```php
class MethodTest {
    public function __call($name, $arguments) {
        echo "calling object method {$name} " . implode(', ', $arguments);
        echo "\n";
    }
}

$obj = new MethodTest();
$obj->runtest('in object context');
var_dump(method_exists($obj, 'runtest')); // bool(false)
var_dump(is_callable(array($obj, 'runtest'))); // bool(true)
```

| 比较内容 | method_exists() | is_callback() |
|--------|--------|--------|
| 适用范围  |   仅适用于判断类方法     |  可以判断全局函数，也可以判断类方法      |
| 是否有上下文       |   否     |   是，会判断一个函数是否在当前环境中可调用     |
| 是否判断权限       |   否     |   是，在类外，判断private 和 protected 方法会返回FALSE     |
| 是否调用_\_call方法       |   否     |   是     |
| 速度       |    快    |    慢    |

## 1.17 执行外部程序

有两种方法 ``out = `ls -al` `` 反引号； 或者函数  `$out = shell_exec('dir')`。

结果是相同的。区别在于，用`` ` `` 符号会将返回结果放在一个数组，而 `shell_exec()` 函数则会将返回结果放在一个标量变量中。

## 1.18 安全模式的使用说明(safe_mode)

![](./images/1.jpg)
![](./images/2.jpg)
![](./images/3.jpg)

## 1.19 提前计算循环长度

foreach 循环是访问数组元素性能最佳的方法，速度远胜于 while、for

## 1.20 SQL 组合优化

## 1.21 文件处理

在操作前，需要确认脚本对某个文件或目录有相应的文件系统的读写权限，包括安全模式及Apache 或 Nginx 的权限设置。

- `fopen()` 函数的模式，请查手册。

- 可以使用 `file()` 函数读取整个文件到一个数组中(可选参数请查手册)：

```php
$lines = file('file_path');
foreach($lines as $line_num => $line) {
    echo "Line #{$line_num} : {$line} n";
}
```

- `file_get_contents()` 函数可以一次读取文件的全部内容，它接受两个额外参数时很有用，分别是 `offset` 和 `MAXLEN`，offset 偏移指定从哪里开始读取，MAXLEN指定从源文件读取的字节数。

- `file_get_contents()` 和 `file_put_contents()` 函数是绝配。可读取远端URL文件。

- `readfile()` 函数会读取文件到输出缓冲区，返回已读取的字节数。

```php
// 使用readfile()
$file = '/home/xiaoming/1.txt';
$bytesRead = readfile($file); //cli模式下，调用直接就输出了
echo $bytesRead; //打印出字节数
```

- `fgets()` 函数 帮我们读取文件时从文件指针的位置开始读取一行，并作为一个字符串返回，也可以指定想让它读取的字节长度。

```php
$file = "file_path";
$handle = fopen($file, 'rt'); //打开文件 返回句柄
if($handle) {
    while(!feof($handle)) { //判断是否到达文件末尾
        $buffer = fgets($handle, 8192);
        echo $buffer;
    }
    fclose($handle);
}
```

- `fread()` 主要用来读取二进制文件。

```php
$file = "file_path";
// 如果是windows系统用rb
$handle = fopen($file, 'r');
$contents = fread($handle, filesize($file));
fclose($handle);
```

- 从一个网址读取一个二进制文件

```php
$handle = fopen('http://i.stack.imgur.com/968et.png', 'r');
$contents = '';
while(FALSE !== $handle && !feof($handle)) {
    $contents = $contents . fread($handle, 8292);
}
FALSE !== $handle && fclose($handle);
var_dump($contents);
```

## 1.22 goto语句：最后的手段（尽量不用）

## 1.23 利用phar扩展来节省空间

![](./images/4.jpg)

```php
include('phar://animals.phar/wild.php'); //注意写法
include('phar://animals.phar/demestic.php');
$test = animal();
//...
```

![](./images/5.jpg)

`phar pack -f animals.phar -c gz wild.php demestic.php`

![](./images/6.jpg)
![](./images/7.jpg)

## 1.24 手册上的小瑕疵

![](./images/8.jpg)

## 1.25 本章小结

# 第2章 深入PHP面向对象

## 2.1 PHP 与面向对象
## 2.2 面向对象的一些概念
## 2.3 类和对象
## 2.4 使用对象
## 2.5 构造方法和析构方法
## 2.6 实例与多态
## 2.7 类的拓展
## 2.8 防止重写

如果将方法声明为 `final` 方法，它不能被任何子类覆盖/重写。

## 2.9 防止被扩展
## 2.10 多态性

`$htmlmailer instanceof emailer` instanceof 关键字，用来判断当前对象与类的关系
## 2.11 接口

方法体必须都是空的，可有属性和指定方法参数。 实现类需要使用关键字 `implements`

```php
interface DBDriver {
    public function connect();  // 注意：没有大括号！！且必须有分号`；`！！
    public function execute($sql);
}
```

## 2.12 抽象类

抽象类和接口几乎相同，只不过抽象类的方法体可以包含内容。 使用关键字 `extended`

```php
abstract class DBDriver { //声明抽象类
    public function connect() {}    // 注意：一定有大括号！！且没有分号`；`！！
    public function execute($sql) {}
}
```

类似声明抽象类，还可以声明抽象方法。当一个方法声明为抽象时，意味着子类必须重写该方法。一个抽象的方法不包含任何内容。声明如下：

`abstract public function connectDB();` //注意：没有大括号！！且必须有分号`；`！！

## 2.13 静态方法和属性
## 2.14 魔术方法

- `__get()` 与 `__set()` 存取类中没有定义的成员方法和属性

 当试图写入已给不存在或者不可见的属性时，PHP就会执行类中的 `__set()`方法.

```php
class myShop {
    private $p = array();

    function __set($name, $value) { //两个参数 属性名称+属性值
        echo "set::$name:$value \n";
        $this->p[$name] = $value; //将属性名及值存入数组中，给__get()调用
    }

    function __get($name) { //一个参数 属性名称
        print "get::$name \n";
        return array_key_exists($name, $this->p) ? $this->p[$name] : null;
    }
}

$shop = new myShop();
$shop->apple = 2;
$shop->pear = 3;
$shop->pear++; //会先执行__get(), 再执行__set()
echo "苹果={$shop->apple}\n";
echo "梨={$shop->pear}\n";
```

输出：

```bash
set::apple:2 
set::pear:3 
get::pear 
set::pear:4 
get::apple 
苹果=2
get::pear 
梨=4
```

- `__call()` 用于调用类中不存在或不可见的方法

试图调用类中一个不存在或不可见的方法时，PHP会执行该类中的 `__call()` 方法。

```php
class MyShop {
    private $obj;

    function __construct($obj) {
        $this->obj = $obj;
    }

    function __call($method, $args) {
        print "{$method}::" . implode($args, ',') . "\n";
        if(isset($this->obj) && method_exists($this->obj, $method)) {
            return call_user_func_array(array($this->obj, $method), $args); //调用某个对象的方法，并传入参数
        }
    }
}

class Calculate {
    private $items = 0;

    function add($num) {
        $this->items += $num;
    }

    function sum() {
        return $this->items;
    }
}

$obj = new Calculate();
$shop = new MyShop($obj);
$shop->add(2);
print $shop->sum() . "\n";
```

输出：

```bash
add::2
sum::
2
```

- `__sleep()` 与 `__wakeup()` 序列化和反序列化一个实例

  `__sleep()`方法在序列化(serialize)一个实例的时候被调用，`__wakeup()`则是在反序列化(unserialize)的时候被调用。注意，`__sleep()`必须返回一个数组或者对象（一般返回的是当前对象`$this`），返回的值将会被用来做序列化的值，如果不返回这个值，则表示序列化失败。这也意味着反序列化不会触发`__wakeup()`事件。

![](./images/9.jpg)

- `__toString()` 把类的实例转化为字符串
- `__autoload()` 自动引入类 大小写敏感

## 2.15 命名空间

绝对不会出错的调用：

```php
namespace Fred;
$courier = new \shipping\Courier();
```

## 2.16 trait(PHP5.4) 解决代码复用问题

用来解决PHP只能单继承的问题，提高代码复用。

```php
Trait examTrait {
    //可定义属性
    //定义了一个方法
    public function dumpObject() {
        echo get_class($this) . "\n"; //打印调用该方法的当前类名
    }

    protected function protected_method() {
        echo "protected_method\n";
    }

    private function private_method() {
        echo "private_method\n";
    }
}

class class_1 {
    use examTrait; //相当于继承了examTrait。跟继承的特性一模一样
}

class class_2 {
    use examTrait;
}

$class_1 = new class_1();
$class_2 = new class_2();

$class_1->dumpObject(); //输出 class_1
$class_2->dumpObject(); //输出 class_2

$class_1->protected_method(); //PHP Fatal error
$class_2->protected_method(); //PHP Fatal error

$class_1->private_method(); //PHP Fatal error
$class_2->private_method(); //PHP Fatal error
```

# 第3章 PHP输出缓冲区

## 3.1 系统缓冲区

缓冲区，实际上是一个内存地址空间，用来解决存储速度不同步的设备或者优先级不同的设备之间的数据传输。

## 3.2 什么是PHP输出缓冲区

- 任何会输出内容的函数都会用到输出缓冲区，如echo、printf()函数。只针对正常的PHP脚本，不包括PHP扩展，有些扩展会将输出写入到SAPI缓冲区层，不需要经过输出缓冲区。
- 输出缓冲区层不是唯一用于缓冲输出的层，它实际上只是多层中的一个。输出缓冲区层的行为与你使用的SAPI(WEB或CLI)有关，不同的SAPI可能有不同的行为。(如下图，最上端的两层就是通常所说的“输出缓冲区”)
![](./images/10.jpg)
- SAPI的输出缓冲区。

`PHP CLI`下的 `php.ini` 配置文件中 `output_buffer` 选项默认是0的，这表示禁用了PHP输出缓冲区。所以在CLI中，默认情况下一旦输出内容就会直接传递到SAPI层，除非手动调用 `ob_()` 类的函数。此外，`implicit_flush()` 的值也被设置为1，这代表一点有任何输出写到SAPI缓冲层，它都会立即刷新（flush,意思是把这些数据写到更底层，并且清空缓冲区）

### 默认PHP输出缓冲区

如果使用不同于CLI的SAPI，比如PHP-FPM，会用到下面3个与缓冲区相关的 `php.ini` 文件的配置选项：

- `output_buffering` 默认为4.96字节，如果设为0，则表示禁用输出缓冲区，如果设为ON，则默认的输出缓冲区大小为16KB
- `implicit_flush` 对于FastCGI协议，该项默认是OFF，每次发送数据包前会先把FastCGI的缓冲区写满再发送，也可调用flush()函数手动刷新。如果希望写一次就刷新一次，可以设置该项为ON,或者调用一次ob_implicit_flush()函数
- `output_handler` 一个回调函数，它可以在缓冲区刷新之前修改缓冲区中的内容。PHP的扩展提供了很多的回调函数（ob_gzhandler、mb_output_handler...也可以自己写）

### 消息头和消息体



不能在运行时使用ini_set()函数修改这几个选项的值，因为不起效果！

